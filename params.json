{
  "name": "Spock-jdbc",
  "tagline": "JDBC related extensions for Spock",
  "body": "# Spock JDBC extensions\r\n\r\nJDBC related extensions for [Spock](http://spockframework.org).\r\n\r\n[![Build Status](https://travis-ci.org/robfletcher/spock-jdbc.svg?branch=master)](https://travis-ci.org/robfletcher/spock-jdbc)\r\n[![Bintray](https://img.shields.io/bintray/v/robfletcher/maven/spock-jdbc.svg?maxAge=2592000)](https://github.com/robfletcher/spock-jdbc)\r\n[![License](https://img.shields.io/badge/license-Apache%202-blue.svg)](https://raw.githubusercontent.com/robfletcher/spock-jdbc/master/LICENSE)\r\n\r\n## Installation\r\n\r\n```groovy\r\ndependencies {\r\n  testCompile \"co.freeside:spock-jdbc:1.0.0\"\r\n}\r\n```\r\n\r\n## Automatic cleanup of test data\r\n\r\nIf you have tests that insert data to a database it's important to ensure the data is cleaned up between tests.\r\nUnfortunately, writing a `cleanup` method that carefully deletes things from the database in the right order is really boring.\r\nAlso, you and I both know you're going to do slightly different things in different tests and 6 months from now something will start leaking and it will take you all morning to figure out why.\r\n\r\nInstead you can use the `@TruncateTables` annotation.\r\n\r\nThe annotation can be applied to a `java.sql.Connection`, `javax.sql.DataSource` or `groovy.sql.Sql` property of the specification.\r\nIn the cleanup phase the extension will use the annotated field to connect to the database and simply delete everything from all tables.\r\n\r\nFor example you could use the annotation in a Spring integration test with a dependency-injected `DataSource` instance like this:\r\n\r\n```groovy\r\n@TruncateTables @Autowired DataSource dataSource\r\n```\r\n\r\n### Foreign key constraints\r\n\r\nThe extension will analyze foreign key constraints on the tables it finds and delete data in an order that will not cause constraint violation exceptions.\r\n\r\n### Using a custom connection source\r\n\r\nIf you want to use `@TruncateTables` with something other than a `Connection`, `DataSource` or `Sql` field you can write an implementation of `Connector` or `TypedConnector` and specify it on the annotation.\r\n\r\nFor example, if you were using [JDBI](http://jdbi.org/) and have a `org.skife.jdbi.v2.DBI` field you could annotate the field with:\r\n\r\n```groovy\r\n@TruncateTables(DBIConnector) DBI dbi\r\n```\r\n\r\nâ€¦ and implement a connector like this:\r\n\r\n```groovy\r\nstatic class DBIConnector extends TypedConnector<DBI> {\r\n  DBIConnector() { super(DBI) }\r\n\r\n  @Override\r\n  protected Connection apply(DBI source) {\r\n    source.open().connection\r\n  }\r\n}\r\n```\r\n\r\n### Connection state\r\n\r\nThe connection will be closed after data is deleted.\r\n\r\nIf you're annotating a raw `Connection` field that might not be ideal.\r\n`DataSource` or something like it that can be used to acquire a fresh connection is really the optimal use-case.\r\n\r\n### Logging activity\r\n\r\nTo log what the extension does:\r\n\r\n```groovy\r\n@TruncateTables(verbose = true)\r\n```\r\n\r\n### Ignoring exceptions\r\n\r\nTo ignore any exceptions encountered when deleting data:\r\n \r\n```groovy\r\n@TruncateTables(quiet = true)\r\n```\r\n### Questions\r\n\r\n#### Can I make it only delete _some_ data?\r\n\r\nNot at the moment.\r\nIf you have a set of \"baseline\" data you will need to re-insert it in your `setup()` method.\r\n\r\n#### Is this useful for tests that run in their own transaction like if I'm using Spring Boot's `@DataJpaTest` or a Grails integration tests?\r\n\r\nNot really.\r\nI have no idea whether the deletion or the transaction rollback would happen first.\r\nEither way would be bad.\r\n\r\n#### Shouldn't I just drop the entire database schema and recreate it for each test?\r\n\r\nThat's also a valid approach.\r\n`@TruncateTables` is for people who don't want to do that for some reason.\r\n\r\n#### I have a circular foreign key constraint, will that be a problem?\r\n\r\nYes. \r\nYes it will. \r\nYou monster.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}